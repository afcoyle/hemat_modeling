if(!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager")
# Get names of all required packages that aren't installed
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[, "Package"])]
new.bioc.packages <- bioconductor.packages[!(bioconductor.packages %in% installed.packages()[, "Package"])]
# Install all new packages
if(length(new.packages)) install.packages(new.packages)
if(length(new.bioc.packages)) BiocManager::install(new.bioc.packages)
# Load all required libraries
all.packages <- c(list.of.packages, bioconductor.packages)
lapply(all.packages, FUN = function(X) {
do.call("require", list(X))
})
# Path to kallisto libraries
kallisto_path <- "../output/kallisto_libraries/hemat_transcriptomev1.6/"
# Libraries we want to read in to our TPM matrix
libraries <- c("178", "118", "132", "073", "151", "113", "173", "072", "127", "359", "349", "334", "221", "254", "222", "272", "294", "280", "463", "481", "485", "427", "445", "425")
# For each row, crab and day should correspond to the order of libraries (ex: 4th row of crabTraits should match libraries[4])
crabTraits <- data.frame("crab" = binarizeCategoricalVariable(x = c(rep(c("A", "B", "C", "D", "E", "F", "G", "H", "I"), times = 2),
"A", "B", "C", "D", "E", "F"),
includePairwise = FALSE,
includeLevelVsAll = TRUE,
minCount = 2),
"day" = factor(c(rep(0, times = 9),
rep(2, times = 9),
rep(17, times = 6))),
"temp" = binarizeCategoricalVariable(x = c(rep("Ambient", times = 12),
rep("Lowered", times = 3),
rep("Elevated", times = 3),
rep("Ambient", times = 3),
rep("Lowered", times = 3)),
includePairwise = TRUE,
includeLevelVsAll = TRUE),
"hemat_level" = scale(c(rep(c(283, 316000, 546000,
761000, 210, 9140,
4510, 120000, 211000), times = 2),
283, 316000, 546000,
761000, 210, 4510)),
"CW" = scale(c(rep(c(132.2, 128.8, 145,
127.4, 134.1, 133.3,
95.7, 111.8, 133.7),
times = 2),
132.2, 128.8, 145,
127.4, 134.1, 133.3), center = TRUE),
"SC" = c(rep("New", times = 5),
rep("Old", times = 2),
rep("New", times = 7),
rep("Old", times = 2),
rep("New", times = 7),
"Old"))
# Create clinical data trait matrix. Same rules as above, but all columns are numeric. Crab A will be noted as 1, B as 2, and C as 3.
crabClinicalData <- data.frame("crab" = binarizeCategoricalVariable(x = c(rep(c(1, 2, 3, 4, 5, 6, 7, 8, 9), times = 2),
1, 2, 3, 4, 5, 6),
includePairwise = FALSE,
includeLevelVsAll = TRUE,
minCount = 2),
"day" = c(rep(0, times = 9),
rep(2, times = 9),
rep(17, times = 6)),
"temp" = binarizeCategoricalVariable(x = c(rep(2, times = 12),
rep(1, times = 3),
rep(3, times = 3),
rep(2, times = 3),
rep(1, times = 3)),
includePairwise = TRUE,
includeLevelVsAll = TRUE),
"hemat_level" = scale(c(rep(c(283, 316000, 546000,
761000, 210, 9140,
4510, 120000, 211000), times = 2),
283, 316000, 546000,
761000, 210, 4510)),
"CW" = scale(c(rep(c(132.2, 128.8, 145,
127.4, 134.1, 133.3,
95.7, 111.8, 133.7),
times = 2),
132.2, 128.8, 145,
127.4, 134.1, 133.3), center = TRUE),
"SC" = c(rep(1, times = 5),
rep(2, times = 2),
rep(1, times = 7),
rep(2, times = 2),
rep(1, times = 7),
2))
# Variable being examined - should match column in two data frames above
variable <- "day"
# Start and ending we want for each file and graph saved
file_start <- paste0("../output/WGCNA_output/hemat_transcriptomev1.6/all_crabs/", variable, "_as_var/")
# Location of blastx table
blastx_table_site <- "../data/hemat_blastx_table_transcriptome_v1.6.txt"
# Number of samples we're examining
numsamples <- 24
# Minimum module size (number of genes per module)
minimum_module <- 10
# Create character vector with all filenames for our libraries
kallisto_files <- paste0(kallisto_path, "id", libraries, "/abundance.tsv")
# Read first kallisto file in to start data frame
TPMcounts <- read.delim(file = kallisto_files[1],
header = TRUE,
sep = "\t")
# Eliminate all columns except transcript ID and TPM
TPMcounts <- TPMcounts %>%
dplyr::select(target_id, tpm)
# Rename columns for consistency and to ID TPM counts
colnames(TPMcounts)[1:2] <- c("Transcript_ID",
paste0("id", libraries[1], "_TPM"))
# Loop through remaining kallisto files, performing full joins to the kallisto file we read in
for (i in 2:length(kallisto_files)){
idnum <- str_extract(kallisto_files[i], "id[0-9]+")
kallisto_output <- read.delim(file = kallisto_files[i],
header = TRUE,
sep = "\t")
# Select only transcript ID and TPM (transcripts per million) columns
kallisto_output <- kallisto_output %>%
dplyr::select(target_id, tpm)
# Rename kallisto column names to give ID to count column
colnames(kallisto_output)[1:2] <- c("Transcript_ID",
paste0(idnum, "_TPM"))
# Add TPM value to table of DEGs
# Perform full join, keeping all transcript IDs
TPMcounts <- full_join(TPMcounts, kallisto_output, by = "Transcript_ID")
}
# Create logical matrix for whole dataframe, comparing values to 10
# Move transcript ID to rownames
TPMcounts <- TPMcounts %>%
column_to_rownames(var = "Transcript_ID")
# Get initial dimensions of data frame
dim(TPMcounts)
# Get number of counts above 10 for each gene
TPMcounts$counts <- rowSums(TPMcounts >= 10)
# Remove all genes without 3+ counts above 10
TPMcounts <- TPMcounts[TPMcounts$counts > 2, ]
# Remove the counts column we just created
TPMcounts <- subset(TPMcounts, select = - counts)
# See how many transcripts we have left
dim(TPMcounts)
# Round all counts to the nearest integer
TPMcounts <- round(TPMcounts, digits = 0)
# Normalize raw counts with DESeq()
crab.dds <- DESeqDataSetFromMatrix(countData = TPMcounts,
colData = crabTraits,
design = as.formula(paste0("~", variable)))
crab.dds <- DESeq(crab.dds)
# Perform vst on DESeq object
vsd <- getVarianceStabilizedData(crab.dds)
# Transpose dataframe to format for WGCNA
CrabExpr0 <- as.data.frame(t(vsd))
# Check dataframe was transposed correctly
dim(CrabExpr0)
# Check for genes and samples with too many missing values
gsg <- goodSamplesGenes(CrabExpr0, verbose = 3)
gsg$allOK      # should return TRUE if all genes pass test
sampleTree <- hclust(dist(CrabExpr0), method = "average")
path <- paste0(file_start, "ClusterDendrogram.png")
png(path)
plot(sampleTree)
dev.off()
# Plot image again, so it shows up in knitted .Rmd
plot(sampleTree)
# Print the crabTraits matrix we made earlier
head(crabTraits)
# Use same rownames as expression data to create analogous  matrix
rownames(crabTraits) <- rownames(CrabExpr0)
# Make sure it looks good
head(crabTraits)
# Create a dendrogram to look at sample and trait clustering
sampleTree2 <- hclust(dist(CrabExpr0), method = "average")
traitColors <- numbers2colors(crabClinicalData, signed = TRUE)
path <- paste0(file_start, "ClusterDendrogram_W_Colors.png")
png(path)
plotDendroAndColors(sampleTree2, traitColors,
groupLabels = names(crabTraits))
dev.off()
# Plot image again, so it shows up in knitted .Rmd
plotDendroAndColors(sampleTree2, traitColors,
groupLabels = names(crabTraits))
# Create set of soft-thresholding powers
powers <- c(c(1:10), seq(from = 12, to = 30, by = 2))
# Use network topology analysis function to eval soft-thresholding power vals
sft <- pickSoftThreshold(CrabExpr0, powerVector = powers, verbose = 5,
networkType = "signed")
path <- paste0(file_start, "ScaleIndependence.png")
png(path)
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
xlab = "Soft Threshold (power)",
ylab = "Scale Free Topology Model Fit, signed R^2",
type = "n",
main = paste("Scale independence"))
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
labels = powers,
cex = 1,
col = "red")
abline(h=0.80, col = "black")
dev.off()
# Plot image again, so it shows up in knitted .Rmd
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
xlab = "Soft Threshold (power)",
ylab = "Scale Free Topology Model Fit, signed R^2",
type = "n",
main = paste("Scale independence"))
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
labels = powers,
cex = 1,
col = "red")
abline(h=0.80, col = "black")
path <- paste0(file_start, "MeanConnectivity.png")
png(path)
plot(sft$fitIndices[,1],sft$fitIndices[,5],
xlab = "Soft Threshold (power)",
ylab = "Mean Connectivity",
type = "n",
main = paste("Mean connectivity"))
# Add sft values
text(sft$fitIndices[,1], sft$fitIndices[,5],
labels = powers,
cex = 1,
col = "red")
dev.off()
# Plot image again, so it shows up in knitted .Rmd
plot(sft$fitIndices[,1],sft$fitIndices[,5],
xlab = "Soft Threshold (power)",
ylab = "Mean Connectivity",
type = "n",
main = paste("Mean connectivity"))
# Add sft values
text(sft$fitIndices[,1], sft$fitIndices[,5],
labels = powers,
cex = 1,
col = "red")
softPower <- 16
adjacency <- adjacency(CrabExpr0, power = softPower,
type = "signed")
# Minimize noise and spurious associations by transforming adjacency into TOM
TOM <- TOMsimilarity(adjacency, TOMType = "signed")
#Calculate dissimilarity matrix
dissTOM <- 1 - TOM
# Clustering using TOM
# Create hierarchical clustering object
geneTree <- hclust(as.dist(dissTOM), method = "average")
path <- paste0(file_start, "GeneDendrogram.png")
png(path)
plot(geneTree, xlab = "", sub = "",
main = "Gene clustering on TOM-based dissimilarity",
labels = FALSE,
hang = 0.04)
dev.off()
# Plot image again, so it shows up in knitted .Rmd
plot(geneTree, xlab = "", sub = "",
main = "Gene clustering on TOM-based dissimilarity",
labels = FALSE,
hang = 0.04)
# Cut branches of dendrogram to ID WGCNA modules
dynamicMods <- cutreeDynamic(dendro =  geneTree,
method = "hybrid",
distM = dissTOM,
deepSplit = 2,
pamRespectsDendro = FALSE,
minClusterSize = minimum_module)
# Look at table of modules
table(dynamicMods)
# Convert module numbers into colors
dynamicColors <- labels2colors(dynamicMods)
path <- paste0(file_start, "GeneDendrogramWColors.png")
png(path)
# Plot dendrogram with module colors
plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut",
dendroLabels = FALSE,
hang = 0.03,
addGuide = TRUE,
guideHang = 0.05,
main = "Gene dendrogram and module colors")
dev.off()
# Plot image again, so it shows up in knitted .Rmd
plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut",
dendroLabels = FALSE,
hang = 0.03,
addGuide = TRUE,
guideHang = 0.05,
main = "Gene dendrogram and module colors")
# Calculate eigengenes
MElist <- moduleEigengenes(CrabExpr0, colors = dynamicColors)
# Save eigengenes as new object
MEs <- MElist$eigengenes
# Calculate dissimilarity of eigengenes
MEDiss <- 1-cor(MEs)
# Create cluster object
METree <- hclust(as.dist(MEDiss), method = "average")
path <- paste0(file_start, "ClusteredEigengenes.png")
png(path)
# Plot dendrogram of clustered eigengenes
plot(METree, main = "Clustering of module eigengenes",
xlab = "",
sub = "")
# ID cut height based on sample number
dynamicMergeCut(numsamples)
MEDissThres <- dynamicMergeCut(numsamples)
abline(h = MEDissThres, col = "red")
dev.off()
# Plot image again, so it shows up in knitted .Rmd
plot(METree, main = "Clustering of module eigengenes",
xlab = "",
sub = "")
# ID cut height based on sample number
dynamicMergeCut(numsamples)
MEDissThres <- dynamicMergeCut(numsamples)
abline(h = MEDissThres, col = "red")
merge <- mergeCloseModules(CrabExpr0, dynamicColors,
cutHeight = MEDissThres,
verbose = 3)
# Extract merged colors and eigengenes
mergedColors <- merge$colors
mergedMEs <- merge$newMEs
path <- paste0(file_start, "ClusterDendrogramOrigAndMergedEigengenes.png")
png(path)
# Plot dendrogram with original and merged eigengenes
plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors),
c("Dynamic Tree Cut", "Merged dynamic"),
dendroLabels = FALSE,
hang = 0.03,
addGuide = TRUE,
guideHang = 0.05)
dev.off()
# Plot image again, so it shows up in knitted .Rmd
plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors),
c("Dynamic Tree Cut", "Merged dynamic"),
dendroLabels = FALSE,
hang = 0.03,
addGuide = TRUE,
guideHang = 0.05)
# Rename and save variables for subsequent analysis
moduleColors <- mergedColors
colorOrder <- c("grey", standardColors(50)) # Determine color order
moduleLabels <- match(moduleColors, colorOrder)-1 # Construct numerical labels based on colors
MEs <- mergedMEs # Replace unmerged MEs
# Count the number of genes and samples
nGenes <- ncol(CrabExpr0)
nSamples <- nrow(CrabExpr0)
# Recalculate MEs with color labels, order MEs based on MEs0
MEs0 <- moduleEigengenes(CrabExpr0, moduleColors)$eigengenes
MEs <- orderMEs(MEs0)
# Remove grey ME (we find out later it only has 5 contigs in it)
MEs <- MEs[names(MEs) != "MEgrey"]
# Calculate trait correlations and obtain p-values
moduleTraitCor <- cor(MEs, crabClinicalData, use = "p")
moduleTraitPvalue <- corPvalueStudent(moduleTraitCor, nSamples)
moduleTraitPvalue
# Create text matrix for correlations and their p-values
textMatrix <- paste(signif(moduleTraitCor, 2), "\n(",
signif(moduleTraitPvalue, 1), ")", sep = "")
# Ensure matrix has same dimensions
dim(textMatrix) == dim(moduleTraitCor)
# We've now made our heatmap, we'll just graph it later
# Define variable using information from trait matrix
key_var <- as.data.frame(crabClinicalData[, variable])
# Modify names
names(key_var) <- variable
# Save module names without "ME" at beginning of each entry
modNames <- substr(names(MEs), 3, nchar(names(MEs)))
# Determine gene significance
# Obtain gene significance statistics
geneTraitSignificance <- as.data.frame(cor(CrabExpr0, key_var, use = "p"))
# Add column names
names(geneTraitSignificance) <- paste("GS.", names(key_var), sep = "")
# Confirm formatting
head(geneTraitSignificance)
# Obtain p-values for each gene significance stat
GSPvalue <- as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
# Add column names
names(GSPvalue) <- paste("p.GS", names(key_var), sep = "")
# Confirm formatting
head(GSPvalue)
# Determine module membership
# Obtain gene module membership stats
geneModuleMembership <- as.data.frame(cor(CrabExpr0, MEs, use = "p"))
# Add column names
names(geneModuleMembership) <- paste("MM", modNames, sep = "")
# Confirm formatting
head(geneModuleMembership)
# Obtain p-values for each module membership statistic
MMPvalue <- as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples))
# Add column names
names(MMPvalue) <- paste("p.MM", modNames, sep = "")
# Confirm formatting
head(MMPvalue)
# Save gene names as probes
probes <- names(CrabExpr0)
# Create dataframe for storing module length (just for heatmap use)
mod_length <- data.frame(modNames, contigs = rep(NA, times = length(modNames)))
# Write out the gene lists for each module of interest
for (module in modNames) {
modGenes <- (moduleColors == module) # Select module probes
modLLIDs <- probes[modGenes] # Get gene IDs
fileName <- paste(file_start, "GeneList-", module, ".txt", sep = "") # Assign filename for each module
mod_length[modNames == module, ]$contigs <- length(modLLIDs) # Get length of each module (for heatmap only)
write.table(as.data.frame(modLLIDs), file = fileName, sep = "\t", row.names = FALSE, col.names = FALSE) # Write out files
}
kME_table <- signedKME(CrabExpr0,
datME = MEs0)
# Write kME file
fileName <- paste0(file_start, "kME_table.txt")
write.table(kME_table, file = fileName,
sep = "\t",
row.names = TRUE,
col.names = TRUE)
# Create labeled heat map of correlation values from textMatrix. Red = positive correlation, blue = negative correlation
path <- paste0(file_start, "ModuleTreatmentHeatMap.png")
png(path)
par(mar = c(10, 8.5, 3, 3))
labeledHeatmap(Matrix = moduleTraitCor,
xLabels = c("Crab A vs. all",
"Crab B vs. all",
"Crab C vs. all",
"Crab D vs. all",
"Crab E vs. all",
"Crab F vs. all",
"Crab G vs. all",
"Grab H vs. all",
"Crab I vs. all",
"Day",
"Elev. vs. Ctrl",
"Low. vs. Ctrl",
"Low. vs. Elev.",
"Ctrl vs. all",
"Elev. vs. all",
"Low. vs. all",
"Infection Level",
"Carapace Width",
"Shell Condition"),
xLabelsAngle = 90,
yLabels = names(MEs),
ySymbols = mod_length$contigs,
colorLabels = FALSE,
colors = blueWhiteRed(50),
textMatrix = textMatrix,
setStdMargins = TRUE,
cex.text = 0.5,
zlim = c(-1, 1))
dev.off()
# Plot image again, so it shows up in knitted .Rmd
par(mar = c(10, 8.5, 3, 3))
labeledHeatmap(Matrix = moduleTraitCor,
xLabels = c("Crab A",
"Crab B",
"Crab C",
"Crab D",
"Crab E",
"Crab F",
"Crab G",
"Grab H",
"Crab I",
"Day",
"Elev. vs. Ctrl",
"Low. vs. Ctrl",
"Low. vs. Elev.",
"Ctrl vs. all",
"Elev. vs. all",
"Low. vs. all",
"Infection Level",
"Carapace Width",
"Shell Condition"),
xLabelsAngle = 90,
yLabels = names(MEs),
ySymbols = mod_length$contigs,
colorLabels = FALSE,
colors = blueWhiteRed(50),
textMatrix = textMatrix,
setStdMargins = TRUE,
cex.text = 0.5,
zlim = c(-1, 1))
knitr::opts_chunk$set(echo = TRUE)
# Add all required libraries here
list.of.packages <- c("ggplot2", "tidyverse", "viridis")
# Get names of all required packages that aren't installed
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[, "Package"])]
# Install all new packages
if(length(new.packages)) install.packages(new.packages)
# Load all required libraries
lapply(list.of.packages, FUN = function(X) {
do.call("require", list(X))
})
# Create data points for graph
# Low, Control, and High are the temperatures in celsius for each
# All values of 7.6 and 7.4 are just to jitter the graph
days <- c(-9, 0, 2, 15, 17)
Decreased <- c(7.4, 7.4, 4, 4, 4)
Control <- rep(7.5, times = 5)
Elevated <- c(7.6, 7.6, 10, 10, NA)
# Assemble into data frame
exp_data <- data.frame(days, Decreased, Control, Elevated)
# Pivot longer
exp_data <- pivot_longer(exp_data, cols = c(Decreased, Control, Elevated), names_to = "Treatment")
# Create another data table for sample events
# This means just removing all data points where day < 0
# as well as the Day 15 data (used to show when the last elevated-temp crab died)
sample_data <- exp_data %>%
filter(days > -1) %>%
filter(days != 15)
# Plot figure
png(file = "../graphs/paper_figures/fig_1.png")
ggplot(data = exp_data, aes(x = days, y = value, group = Treatment)) +
geom_line(size = 1.5, aes(color = Treatment)) +
geom_point(data = sample_data, size = 3, color = "gray30") +
theme_bw() +
scale_color_manual(values = c("#00BA38", "#619CFF", "#F8766D")) +
xlab("Experimental Days") +
ylab("Temperature (Celsius)")
dev.off()
ggplot(data = exp_data, aes(x = days, y = value, group = Treatment)) +
geom_line(size = 1.5, aes(color = Treatment)) +
geom_point(data = sample_data, size = 3, color = "gray30") +
theme_bw() +
scale_color_manual(values = c("#00BA38", "#619CFF", "#F8766D")) +
xlab("Experimental Days") +
ylab("Temperature (Celsius)")

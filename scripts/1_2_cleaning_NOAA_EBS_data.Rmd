---
title: "1_2_cleaning_NOAA_EBS_data"
author: "Aidan Coyle"
date: "6/26/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Background

This script deals with the NOAA EBS data on _Hematodinium_ infection, obtained by the Roberts lab from Pam Jensen. These data contain _Hematodinium_ test infection results from the annual NOAA Eastern Bering Sea (EBS) trawl surveys from 2014 to 2019.

Since files do not have consistent formatting and organization, each is read in separately rather than in a single loop.

#### Load libraries (and install if necessary)

```{r libraries, message=FALSE, warning=FALSE}
# Add all required libraries here
list.of.packages <- c("tidyverse", "readxl", "lubridate", "rnaturalearth", "rnaturalearthdata", "sf", "rgeos")
# Get names of all required packages that aren't installed
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[, "Package"])]
# Install all new packages
if(length(new.packages)) install.packages(new.packages)


# Load all required libraries
lapply(list.of.packages, FUN = function(X) {
  do.call("require", list(X))
})
```
#### See all files to be read in
```{r}
# Get a list of all our data files
files <- paste0("../data/NOAA_EBS_trawl_survey/", list.files(path = "../data/NOAA_EBS_trawl_survey/"))
# Display all files we'll be reading in
files
```


#### Read in 2014 data
```{r}
# Read in file from 2014
full_data <- read_excel(files[1], sheet = 2)

# See first few lines of full data sheet
head(full_data)
```

#### Read in 2015 data
```{r}
# Read in file from 2015
new_data <- read_excel(files[2], sheet = 2)

# Check if names match between the two years
all_equal(new_data, full_data, ignore_col_order = FALSE)

# Appears that the differences are solely in formatting (Chela -> chela and STATIONID -> STATION ID). Let's fix those so the 2015 data match the 2014 data
new_data <- new_data %>%
  rename(
    Chela = chela,
    STATIONID = "STATION ID"
  )

# See if we have any other mismatches
all_equal(new_data, full_data, ignore_col_order = FALSE, convert = TRUE)

# Join the 2015 data to the 2014 data
full_data <- bind_rows(full_data, new_data)
```

#### Read in 2016 data
```{r}
# Read in file from 2016
new_data <- read_excel(files[3], sheet = 2)

# Check if names match between 2016 data and our full_data table
all_equal(new_data, full_data, ignore_col_order = FALSE)

# Again, appears that the mismatches in column names are simple differences in name formatting, not overall sheet organization. Therefore we can simply rename our columns
new_data <- new_data %>%
  rename(
    Chela = chela,
    "PCR result" = "PCR Result",
    "Host_Tissue" = "Host Tissue"
  )

# See if we have any other mismatches
all_equal(new_data, full_data, ignore_col_order = FALSE, convert = TRUE)

# Convert START TIME column from character to POSIX
new_data$`START TIME` <- strptime(new_data$`START TIME`, format = '%m/%d/%Y %H:%M')

# See if we have any other mismatches
all_equal(new_data, full_data, ignore_col_order = FALSE, convert = TRUE)

# Join the 2016 data to the table with data from previous years
full_data <- bind_rows(full_data, new_data)
```

#### Read in 2017 data

```{r}
# Read in file from 2017
new_data <- read_excel(files[4], sheet = 2)

# Check if names match between 2017 data and our full_data table
all_equal(new_data, full_data, ignore_col_order = FALSE)

# Again, appears that the mismatches in column names are simple differences in name formatting, not overall sheet organization. Therefore we can simply rename our columns
new_data <- new_data %>%
  rename(
    Chela = chela,
    "Host_Tissue" = "Host Tissue"
  )

# See if we have any other mismatches
all_equal(new_data, full_data, ignore_col_order = FALSE, convert = TRUE)

# Join the 2017 data to the table with data from previous years
full_data <- bind_rows(full_data, new_data)
```

#### Read in 2018 data

```{r}
# Read in file from 2018
new_data <- read_excel(files[5], sheet = 2)

# Check if names match between 2018 data and our full_data table
all_equal(full_data, new_data)

# Looks like there are 5 extra columns in the 2018 data. Let's see where these are
names(new_data)[names(full_data) != names(new_data)]

# Appears that in 2018 alternative definitions of maturity began to be examined. This resulted in extra columns for ln(CW), meas'd ln(Ch), calc ln(Ch), mat, and Mat1. Because there's some odd variable names there, remove based on indexing
new_data <- new_data[, -c(6:10)]

# Check again if names match between 2018 data and our full_data table
all_equal(full_data, new_data)

# Again, appears that the mismatches in column names are simple differences in name formatting, not overall sheet organization. Therefore we can simply rename our columns
new_data <- new_data %>%
  rename(
    Chela = chela,
    "Host_Tissue" = "Host Tissue"
  )

# See if we have any other mismatches
all_equal(new_data, full_data, ignore_col_order = FALSE, convert = TRUE)

# Join the 2018 data to the table with data from previous years
full_data <- bind_rows(full_data, new_data)
```

#### Read in 2019 data

```{r}
# Read in file from 2019
new_data <- read_excel(files[6], sheet = 3)

# Check if names match between 2019 data and our full_data table
all_equal(full_data, new_data)

# Looks like there are 9 extra columns in the 2019 data. Let's see where these are
names(new_data)[names(full_data) != names(new_data)]

# Appears that the examination of alternative definitions of maturity continued. This resulted in six extra columns noting chela height and carapace width calculations. Furthermore, there are three columns on the end that should be removed - they appear to have been used only for calculations. Because there's some odd variable names there, remove based on indexing
new_data <- new_data[, -c(5, 7:11, 43:45)]

# Check again if names match between 2019 data and our full_data table
all_equal(full_data, new_data)

# Again, appears that the mismatches in column names are simple differences in name formatting, not overall sheet organization. Therefore we can simply rename our columns
new_data <- new_data %>%
  rename(
    Chela = chela,
    "Host_Tissue" = "Host Tissue",
    VESSEL = Vessel,
    HAUL = Haul
  )

# See if we have any other mismatches
all_equal(new_data, full_data, ignore_col_order = FALSE, convert = TRUE)

# Join the 2019 data to the table with data from previous years
full_data <- bind_rows(full_data, new_data)
```

#### End of data import

#### Clean up column names so that none contain spaces

```{r}
names(full_data) <- str_replace_all(names(full_data), c(" " = "_", "," = ""))
```


We now have a single table (full_data) that contains approximately 7100 rows, with each row corresponding to the test results for a single crab. However, not all columns contain information relevant to the model. Therefore, we will now remove those columns from the data. We will remove the following columns for the following reasons:

SPNO: Gives the row number for that year, which we don't care about

Random: Contains NAs in all rows except 3

Collection_Comments: Checked, and no rows contain info relevant to model

ANOM_ID: Contains no useful information

General_Location: For all, is BS (Bering Sea)

Collected_By: Collector should be irrelevant

Reference_NO: Used for testing, irrelevant once PCR results obtained

DNA_Plate_No: Used for testing, irrelevant once PCR results obtained

DNA_Well_No: Used for testing, irrelevant once PCR results obtained

Host_Tissue: Either leg muscle or blood, should be irrelevant after PCR testing

Preservative: Irrelevant after PCR results obtained

Sample_Status: Irrelevant after PCR results obtained

C_V_H: Amalgamation of three other columns (CRUISE, VESSEL, and HAUL)

CRUISE: Survey leg is irrelevant once collection has been made

VESSEL: Also does not matter after collection

HAUL: Haul number of survey does not matter after collection

GEAR_DEPTH: Also have a column for BOTTOM DEPTH, and it would be quite surprising if any mid-water trawls picked up crab!

SURFACE_TEMP: Also have a column for bottom temp, which is more relevant for crab conditions

```{r}
full_data <- subset(full_data, select = -c(SPNO, Random, Collection_Comments, ANOM_ID, General_Location, Collected_By, Reference_NO, DNA_Plate_No, DNA_Well_No, Host_Tissue, Preservative, Sample_Status, C_V_H, CRUISE, VESSEL, HAUL, GEAR_DEPTH, SURFACE_TEMP))
```

#### Examining Additional Variables to Eliminate

```{r}
table(full_data$Egg_Cond)
# Can eliminate - indicates little beyond egg presence
full_data <- subset(full_data, select = -Egg_Cond)

table(full_data$Specific_Location)
# Can eliminate - sites are year-specific
full_data <- subset(full_data, select = -Specific_Location)

table(full_data$Egg_Color, full_data$PCR_result)
# Practically all eggs are either 0 (absent) or 4 (orange). We already have clutch fullness data which provides presence/absence information (and more), so this column can be removed.
full_data <- subset(full_data, select = -Egg_Color)

table(full_data$STRATUM, full_data$Year)
# Looks like for all of 2008, we have almost entirely NAs. Therefore, rather than losing a year, let's drop and use latitude/longitude. Since we're using latitude/longitude, we'll also drop STATIONID
full_data <- subset(full_data, select = -c(STRATUM, STATIONID))
```

#### Modifying Categorical Variables

We will now examine and eliminate unnecessary complexity by grouping variable categories and eliminating minimally-represented variation

```{r}
# First, we will convert START_TIME to Julian day (day from the start of the year)
full_data$JUL_DAY <- yday(full_data$START_TIME)
hist(full_data$JUL_DAY)
# We can now drop the START_TIME column
full_data <- subset(full_data, select = -START_TIME)

table(full_data$Sex)
sum(is.na(full_data$Sex))
# Eliminate all 4 rows where sex is unknown (=3), along with the 6 rows where sex is NA
full_data <- subset(full_data, Sex < 3)

table(full_data$Species_Name)
# Eliminate the one helmet crab included in the data set
full_data <- subset(full_data, Species_Name != "Telmessus cheiragonus")

table(full_data$Shell_Cond)
sum(is.na(full_data$Shell_Cond))
# #liminate all 0s, 1s, and 2s (soft-, fresh- and very very old-shell crab. 10 total among all 3 categories). Also eliminates the 10 crabs with NA shell condition
full_data <- subset(full_data, Shell_Cond < 5 & Shell_Cond > 1)

table(full_data$Clutch)
# Given the relatively small number of crabs with eggs, I think it makes more sense to change this to 0 (no eggs present) and 1 (eggs present). Essentially, all crabs with egg codes from 1-6 will be converted to egg code 1
full_data$Clutch <- recode_factor(full_data$Clutch, "0" = "0", "1" = "1", "2" = "1", "3" = "1", "4" = "1", "5" = "1", "6" = "1")

table(full_data$PCR_result)
# Only want to keep conclusive PCR results, so eliminating all NAs and 3s
full_data <- subset(full_data, PCR_result < 2)

table(full_data$Year)
```

#### Eliminating NAs

We eliminated some NAs above, but want to examine in more detail to see how many are feasible to eliminate

```{r}
colSums(is.na(full_data))

# Looks like the only NAs are for chela height and clutch condition. NAs in these categories are expected - chela height is not measured for females and clutch size is not measured for females. However, let's verify in more detail

colSums(is.na(full_data[full_data$Sex == 1, ]))
colSums(is.na(full_data[full_data$Sex == 2, ]))

# Looks like we do have NAs for chela height for males and NAs for clutch condition for females. We'll sort those out later, when we create sex-specific dataframes

# Otherwise, looks like we've already sorted out our NAs!
```

#### Checking for Data Entry Errors for Continuous Variables

```{r}
# Since male and female Chionoecetes crab have quite different sizes, we'll check for each of these separately
hist(full_data[full_data$Sex == 1, ]$Size)
hist(full_data[full_data$Sex == 2, ]$Size)
summary(full_data[full_data$Sex == 1, ]$Size)
summary(full_data[full_data$Sex == 2, ]$Size)
# Looks like no data entry errors for size!

# Now moving on to chela height
hist(full_data$Chela)
summary(full_data$Chela)
# Looks like no data entry errors for chela height

# Now moving on to latitude and longitude. For this, we will map each point
world <- ne_countries(scale = "medium", returnclass = "sf")
ggplot(data = world) +
  geom_sf() +
  geom_point(data = full_data, aes(x = START_LONGITUDE, y = START_LATITUDE), size = 1, shape = 23, fill = "darkred")

# No global data entry errors - all are clustered within the EBS region. However, let's examine on a smaller scale
ggplot(data = world) +
  geom_sf() +
  geom_point(data = full_data, aes(x = START_LONGITUDE, y = START_LATITUDE), size = 1, shape = 23, fill = "darkred") +
  coord_sf(xlim = c(-180, -160), ylim = c(50, 70), expand = FALSE)

# From this map, it appears that our points fall into 6 distinct clusters - Bristol Bay, Pribilof Islands, outer shelf south, St. Matthew Island, outer shelf north, and Bering Strait. This indicates we may want to modify this into a categorical variable rather than a continuous one
# However, we will address that later. No data entry errors seem apparent

# Moving on to bottom depth
hist(full_data$BOTTOM_DEPTH)
summary(full_data$BOTTOM_DEPTH)
# No data entry errors apparent

# Moving on to bottom temperature
hist(full_data$Bottom_Temp)
summary(full_data$Bottom_Temp)
# A temperature of 9 degrees seems anomalous - let's examine further
head(sort(unique(full_data$Bottom_Temp), decreasing = TRUE))
# It certainly is high, but not high enough to conclude a data entry error was made

# Moving on to
hist(full_data$JUL_DAY)
# No data entry errors apparent - all seem within standard survey date ranges
```

#### Modifying Latitude/Longitude into a Categorical Variable



min(full_data$WIDTH_MILLIMETERS)

max(full_data[full_data$SEX_CODE == "M", ]$WIDTH_MILLIMETERS)

max(full_data[full_data$SEX_CODE == "F", ]$WIDTH_MILLIMETERS)



